<meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=no">
<link rel="manifest" href="mustache.json">
<title>Mustache</title>
<style>
  html, body {
    margin: 0 auto;
    height: 100%;
    background: rgb(51, 51, 58);
    color: #fff;
    user-select: none;
    overflow: hidden;
  }
  video {
    display: none;
  }
  canvas {
    width: 100vw;
    height: 100vh;
  }
  pre {
    position: absolute;
    top: 24px;
    left: 24px;
    white-space: pre-line;
    right: 24px;
    text-shadow: 0 0 black;
   }
  #mustache {
    display: none;
  }
  .bottomBar {
    position: absolute;
    bottom: 0;
    right: 0;
    left: 0;
    height: 128px;
    background-color: rgba(51, 51, 58, 0.3);
  }
  .recording .bottomBar {
    opacity: 0;
  }
  #recordButton {
    will-change: transform, background;
    transition: transform .1s ease-out;
    position: absolute;
    bottom: 36px;
    right: 0;
    text-align: center;
    left: 0;
    width: 10px;
    margin: auto;
    background: rgb(0, 193, 233);
    line-height: 64px;
    border-radius: 50%;
    box-shadow: 0 0 2px 0 rgb(51, 51, 58);
    height: 10px;
    border: 27px solid rgb(7, 104, 125);
  }
  .recording #recordButton {
    background: red;
    border-color: red;
  }
  #preview {
    transform: translateX(120px);
    will-change: transform;
    transition: .1s transform ease-in;
  }
  #previewVideo {
    width: 92px;
    position: absolute;
    bottom: 72px;
    right: 24px;
    background: black;
    display: block;
    border: 2px solid #F44336;
    border-bottom: 0;
  }
  #shareButton {
    position: absolute;
    bottom: 70px;
    right: 24px;
    text-align: center;
    width: 96px;
    background: #F44336;
    line-height: 48px;
    font-family: Roboto;
    font-weight: bold;
    cursor: default;
    will-change: transform;
    transition: .1s transform ease-in;
  }
  #shareButton[data-url] {
    transform: translateY(46px);
  }
  .visible {
    transform: translateX(0) !important;
  }
</style>
<canvas id="canvas"></canvas>
<video id="video" autoplay muted></video>
<div class="bottomBar"></div>
<img id="mustache" src="mustache.png">
<div id="recordButton"></div>
<div id="preview">
  <div id="shareButton">SHARE</div>
  <video id="previewVideo" autoplay muted loop></video>
</div>
<pre id="log"></pre>
<div id="debug" style="position: absolute; background-color: rgba(0, 0, 0, 0.5); border-radius: 4px; bottom: 138px; padding: 4px; color: white; left: 6px; display: none">
  <input type="checkbox" id="canvasSize" onchange="changeCanvasSize()"><label for="canvasSize">Big Canvas</label><br/>
  <input type="checkbox" id="mirror" onchange="changeMirror()"><label for="mirror">Mirror</label><br/>
  <input type="checkbox" id="detectFaces" onchange="changeDetectFaces()"><label for="detectFaces">Detect Faces</label><br/>
</div>
<script>

/* Debug stuff */
document.querySelector('.bottomBar').addEventListener('click', event => {
  debug.style.display = (debug.style.display === 'none') ? 'block' : 'none';
});

function changeCanvasSize() {
  if (canvasSize.checked) {
    canvas.height = window.innerHeight * devicePixelRatio;
    canvas.width = window.innerWidth * devicePixelRatio;
  } else {
    canvas.height = window.innerHeight;
    canvas.width = window.innerWidth;
  }
  // HACK: Face Detector doesn't accept canvas whose width is odd.
  if (canvas.width % 2 == 1) {
    canvas.width += 1;
  }
  log.textContent = `Video: ${video.videoWidth}x${video.videoHeight}, Canvas: ${canvas.width}x${canvas.height}`;
}

function changeDetectFaces() {
  if (!detectFaces.checked) {
    window.location.search = 'isDetectingFaces=true';
  } else {
    window.location.search = '';
  }
}

function changeMirror() {
  // Mustaches look great in mirrors.
  canvas.getContext('2d').translate(canvas.width, 0);
  canvas.getContext('2d').scale(-1, 1);
}

/* End of Debug stuff */

let face = null;

let recorder;
let chunks = [];

let isDetectingFaces = new URL(location).searchParams.has('isDetectingFaces');
// Debug stuff
detectFaces.checked = !isDetectingFaces;

(async _ => {
  // Grab camera stream.
  const constraints = {
     video: {
       facingMode: 'user',
       frameRate: 60,
       width: 4048,
       height: 3036,
     }
  };
  video.srcObject = await navigator.mediaDevices.getUserMedia(constraints);
  await video.play();

  canvas.height = window.innerHeight;
  canvas.width = window.innerWidth;
  // HACK: Face Detector doesn't accept canvas whose width is odd.
  if (canvas.width % 2 == 1) {
    canvas.width += 1;
  }

  requestAnimationFrame(draw);

  recordButton.addEventListener('pointerdown', startRecording);
  recordButton.addEventListener('pointerleave', stopRecording);
})();

async function draw() {
  requestAnimationFrame(draw);

  const context = canvas.getContext('2d');

  // Draw video frame.
  const ratio  = Math.max(canvas.width / video.videoWidth, canvas.height / video.videoHeight);
  context.drawImage(video, 0, 0, video.videoWidth, video.videoHeight,
      (canvas.width - video.videoWidth * ratio) / 2, 0,
      video.videoWidth * ratio, video.videoHeight * ratio);  

  // Draw mustache on previously detected face.
  if (face) {
    /*
    context.beginPath();
    context.rect(face.x, face.y, face.width, face.height);
    context.lineWidth = 4;
    context.strokeStyle = 'deeppink';
    context.stroke();
    */
    context.drawImage(mustache,
        face.left,
        face.bottom - mustache.height * face.width / mustache.width / 2,
        face.width,
        mustache.height * face.width / mustache.width);
  }

  if (isDetectingFaces) {
    return;
  }

  // Detect new faces.
  isDetectingFaces = true;
  const faceDetector = new FaceDetector({ fastMode: true, maxDetectedFaces: 1 });
  const faces = await faceDetector.detect(canvas);
  if (faces.length) {
    // Let's overwrite face only when a new one is found.
    face = faces[0].boundingBox;
  }
  isDetectingFaces = false;
}

function startRecording() {
  console.count('startRecording');
  preview.classList.remove('visible');
  document.body.classList.add('recording');
  shareButton.removeAttribute('data-url');

  const stream = canvas.captureStream();
  recorder = new MediaRecorder(stream, { mimeType: 'video/webm;codecs=h264' });
  recorder.start(10); // collect 10ms of data
  recorder.addEventListener('dataavailable', event => { chunks.push(event.data); });
  recorder.addEventListener('stop', async event => {
    const blob = new Blob(chunks, { type: 'video/webm' });

    previewVideo.src = URL.createObjectURL(blob);
    await previewVideo.play();
    URL.revokeObjectURL(previewVideo.src);
    preview.classList.add('visible');

    uploadVideo(blob);
    chunks = [];
  });
}

async function stopRecording() {
  console.count('stopRecording');
  recorder.stop();
  document.body.classList.remove('recording');

  // HACK to be able to play preview video later!
  previewVideo.play();
}

async function uploadVideo(blob) {
  const url = new URL('https://www.googleapis.com/upload/storage/v1/b/pwa-mustache/o');
  url.searchParams.append('uploadType', 'media');
  url.searchParams.append('name', Date.now() + '.webm');

  // Upload video to Google Cloud Storage.
  const response = await fetch(url, {
    method: 'POST', 
    body: blob,
    headers: new Headers({
      'Content-Type': 'video/webm',
      'Content-Length': blob.length
    })
  });
  const data = await response.json();
  shareButton.dataset.url = data.mediaLink;
}

shareButton.addEventListener('click', event => {
  navigator.share({
    title: 'Mussssss',
    text: 'Look at my mustaches!',
    url: event.target.dataset.url
  });
});

window.addEventListener('unhandledrejection', event => {
  log.textContent = event.reason;
});

// Prevent context menu on desktop touch screen...
window.oncontextmenu = _ => { return false; };
</script>


